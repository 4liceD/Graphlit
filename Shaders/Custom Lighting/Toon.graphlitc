float lilTooningNoSaturateScale(float aascale, float value, float border, float blur)
{
    float borderMin = saturate(border - blur * 0.5);
    float borderMax = saturate(border + blur * 0.5);
    return (value - borderMin) / saturate(borderMax - borderMin + fwidth(value) * aascale);
}
float lilTooningNoSaturateScale(float aascale, float value, float border, float blur, float borderRange)
{
    float borderMin = saturate(border - blur * 0.5 - borderRange);
    float borderMax = saturate(border + blur * 0.5);
    return (value - borderMin) / saturate(borderMax - borderMin);
}

#pragma skip_variants SHADOWS_SOFT SHADOWS_CUBE POINT_COOKIE LIGHTMAP_ON
#define CUSTOM_LIGHT
LIGHT_FUNC // args: light, fragData, giInput, surf, giOutput
{
    half defaultAtten = saturate(light.attenuation);
    #if defined(SHADOWS_SCREEN) && !defined(_CBIRP)
        defaultAtten = 1;
    #endif

    half3 col = light.color * defaultAtten;
    half3 defaultCol = col;

    const float antialias = 1.0;

    half4 lns = 1.0;

    half NoL2 = saturate(dot(light.direction, giInput.normalWS) * 0.5 + 0.5);
    lns.x = NoL2;
    lns.y = NoL2;
    lns.z = NoL2;

    lns.xyz *= lerp(defaultAtten, light.attenuation, surf.ShadowReceive);

    lns.w = lns.x;
    lns.x = lilTooningNoSaturateScale(antialias, lns.x, surf.ShadowBorder.x, surf.ShadowBlur.x);
    lns.y = lilTooningNoSaturateScale(antialias, lns.y, surf.ShadowBorder.y, surf.ShadowBlur.y);
    lns.z = lilTooningNoSaturateScale(antialias, lns.z, surf.ShadowBorder.z, surf.ShadowBlur.z);
    lns.w = lilTooningNoSaturateScale(antialias, lns.w, surf.ShadowBorder.x, surf.ShadowBlur.x, surf.ShadowBorderRange);

    lns = saturate(lns);

    lns = lerp(1.0, lns, surf.ShadowMask);
    col = lerp(col, lerp(defaultCol * surf.Shadow1Color.rgb, col, lns.x), 1.0);
    col = lerp(col, lerp(defaultCol * surf.Shadow2Color.rgb, col, lns.y), surf.Shadow2Color.a);
    col = lerp(col, lerp(defaultCol * surf.Shadow3Color.rgb, col, lns.z), surf.Shadow3Color.a);

    col = lerp(col, defaultCol, lns.w * surf.ShadowBorderColor.rgb);


    #ifdef _TOONSHADOW
        giOutput.directDiffuse += col;
    #else
        giOutput.directDiffuse += light.color * defaultAtten;
    #endif
}

float OpenLitGray(float3 rgb)
{
    return dot(rgb, float3(1.0/3.0, 1.0/3.0, 1.0/3.0));
}

void ShadeSH9ToonDouble(float3 lightDirection, out float3 shMax, out float3 shMin)
{
    #if !defined(LIGHTMAP_ON)
        float3 N = lightDirection * 0.666666;
        float4 vB = N.xyzz * N.yzzx;
        // L0 L2
        float3 res = float3(unity_SHAr.w,unity_SHAg.w,unity_SHAb.w);
        res.r += dot(unity_SHBr, vB);
        res.g += dot(unity_SHBg, vB);
        res.b += dot(unity_SHBb, vB);
        res += unity_SHC.rgb * (N.x * N.x - N.y * N.y);
        // L1
        float3 l1;
        l1.r = dot(unity_SHAr.rgb, N);
        l1.g = dot(unity_SHAg.rgb, N);
        l1.b = dot(unity_SHAb.rgb, N);
        shMax = res + l1;
        shMin = res - l1;
        #if defined(UNITY_COLORSPACE_GAMMA)
            shMax = OpenLitLinearToSRGB(shMax);
            shMin = OpenLitLinearToSRGB(shMin);
        #endif
    #else
        shMax = 0.0;
        shMin = 0.0;
    #endif
}

// should be moved to another func for indirect diffuse when its added so it runs earlier
#define CUSTOM_COLOR
COLOR_FUNC // args: surf, fragData, giInput, giOutput
{
    #if defined(UNITY_PASS_FORWARDBASE)
        float3 sh9Dir = unity_SHAr.xyz * 0.333333 + unity_SHAg.xyz * 0.333333 + unity_SHAb.xyz * 0.333333;
        float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
        half3 N = normalize(sh9DirAbs);
        UNITY_FLATTEN
        if (!any(unity_SHC.xyz))
        {
            N = 0;
        }

        half3 shMin;
        half3 shMax;
        ShadeSH9ToonDouble(N, shMin, shMax);
        half3 indirectColor = shMin;

        Light lightprobe = (Light)0;
        lightprobe.color = indirectColor;
        lightprobe.direction = N;
        lightprobe.attenuation = 1.0;
        lightprobe.ComputeData(fragData, giInput);
        LightCustom(lightprobe, fragData, giInput, surf, giOutput);
        giOutput.indirectOcclusion = 1.0;
    #endif

    half3 lightColor = giOutput.directDiffuse;

    half lightRenorm = max(max(lightColor.r, lightColor.g), lightColor.b);
    if (lightRenorm > _LightMaxLimit)
    {
        lightColor /= lightRenorm / _LightMaxLimit;
    }
    lightColor = min(_LightMaxLimit, lightColor);
    lightColor = max(_LightMinLimit, lightColor);
    lightColor = lerp(lightColor, OpenLitGray(lightColor), _MonochromeLighting);

    // swap to apply ao
    giOutput.directDiffuse = 0;
    giOutput.indirectDiffuse = lightColor;
    half4 color = COLOR_DEFAULT;
    
    return color;
}


// MIT License

// Copyright (c) 2020-2024 lilxyzw

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.