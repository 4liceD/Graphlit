float lilTooningNoSaturateScale(float aascale, float value, float border, float blur)
{
    float borderMin = saturate(border - blur * 0.5);
    float borderMax = saturate(border + blur * 0.5);
    return (value - borderMin) / saturate(borderMax - borderMin + fwidth(value) * aascale);
}

#pragma skip_variants SHADOWS_CUBE SHADOWS_SOFT POINT_COOKIE SHADOWS_DEPTH LIGHTMAP_ON
#define CUSTOM_LIGHT
LIGHT_FUNC // args: light, fragData, giInput, surf, giOutput
{
    #if defined(UNITY_PASS_FORWARDBASE)
    if (all(light.color == 0))
    {
        float3 sh9Dir = unity_SHAr.xyz + unity_SHAg.xyz + unity_SHAb.xyz;
        float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
        half3 N = normalize(sh9DirAbs);
        UNITY_FLATTEN
        if (!any(unity_SHC.xyz))
        {
            N = 0;
        }

        light.direction = N;
        light.color = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
        light.attenuation = 1.0;
    }
    #endif

    half3 col = light.color * light.attenuation;
    half defaultAtten = light.attenuation;
    #ifdef SHADOWS_SCREEN
        defaultAtten = 1;
    #endif

    const float antialias = 1.0;
    half4 lns = 1.0;

    // layer 1
    lns.x = saturate(dot(light.direction, giInput.normalWS) * 0.5 + 0.5);
    lns.x *= lerp(defaultAtten, light.attenuation, _ShadowReceive);
    lns.x = saturate(lilTooningNoSaturateScale(antialias, lns.x, _ShadowBorder, _ShadowBlur));
    col = lerp(col * lerp(1.0, _ShadowColor.rgb, _ShadowColor.a), col, lns.x);

    //layer 2
    lns.y = saturate(dot(light.direction, giInput.normalWS) * 0.5 + 0.5);
    lns.y *= lerp(defaultAtten, light.attenuation, _Shadow2ndReceive);
    lns.y = saturate(lilTooningNoSaturateScale(antialias, lns.y, _Shadow2ndBorder, _Shadow2ndBlur));
    col = lerp(col * lerp(1.0, _Shadow2ndColor.rgb, _Shadow2ndColor.a), col, lns.y);

    //layer 3
    lns.z = saturate(dot(light.direction, giInput.normalWS) * 0.5 + 0.5);
    lns.z *= lerp(defaultAtten, light.attenuation, _Shadow3rdReceive);
    lns.z = saturate(lilTooningNoSaturateScale(antialias, lns.z, _Shadow3rdBorder, _Shadow3rdBlur));
    col = lerp(col * lerp(1.0, _Shadow3rdColor.rgb, _Shadow3rdColor.a), col, lns.z);

    lns = lerp(1.0, lns, _ShadowStrength);

    #ifdef _TOONSHADOW
        giOutput.directDiffuse += col;
    #else
        giOutput.directDiffuse += light.color * defaultAtten;
    #endif
}

float OpenLitGray(float3 rgb)
{
    return dot(rgb, float3(1.0/3.0, 1.0/3.0, 1.0/3.0));
}

// should be moved to another func for indirect diffuse when its added so it runs earlier
#define CUSTOM_COLOR
COLOR_FUNC // args: surf, fragData, giInput, giOutput
{
    #if !defined(LIGHTMAP_ON) && defined(UNITY_PASS_FORWARDBASE)
        float3 sh9Dir = unity_SHAr.xyz + unity_SHAg.xyz + unity_SHAb.xyz;
        float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
        half3 N = normalize(sh9DirAbs);
        UNITY_FLATTEN
        if (!any(unity_SHC.xyz))
        {
            N = 0;
        }
        half3 l0l1 = SHEvalLinearL0L1(float4(N, 1));
        half3 l2 = SHEvalLinearL2(float4(N, 1));
        giOutput.indirectDiffuse = l0l1 + l2;
        giOutput.indirectOcclusion = giOutput.indirectDiffuse;
        // giOutput.indirectDiffuse = 0;
    #endif

    #ifndef LIGHTMAP_ON
        giOutput.indirectSpecular = 0;
        giOutput.directSpecular = 0;

        half lightRenorm = max(max(giOutput.directDiffuse.r, giOutput.directDiffuse.g), giOutput.directDiffuse.b);
        lightRenorm += max(max(giOutput.indirectDiffuse.r, giOutput.indirectDiffuse.g), giOutput.indirectDiffuse.b);
        giOutput.indirectDiffuse += giOutput.directDiffuse;
        giOutput.directDiffuse = 0;
        if (lightRenorm > _LightMaxLimit)
        {
            giOutput.indirectDiffuse /= lightRenorm / _LightMaxLimit;
        }
        giOutput.indirectDiffuse = max(_LightMinLimit, giOutput.indirectDiffuse);
        giOutput.indirectDiffuse = lerp(giOutput.indirectDiffuse, OpenLitGray(giOutput.indirectDiffuse), _MonochromeLighting);
    #endif

    half4 color = COLOR_DEFAULT;
    
    return color;
}


// MIT License

// Copyright (c) 2020-2024 lilxyzw

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.